package com.taskforge.dao;

import com.taskforge.model.Task;
import com.taskforge.model.User;
import com.taskforge.model.Project;
import com.taskforge.model.Priority;
import com.taskforge.model.Status;
import com.taskforge.model.Visibility; // Import the new Visibility enum
import com.taskforge.util.DatabaseManager;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * Data Access Object (DAO) for the Task entity.
 * This class provides methods to perform CRUD (Create, Read, Update, Delete)
 * operations on the 'Tasks' table in the database.
 * It handles associations with User and Project entities, and conversions for LocalDateTime.
 */
public class TaskDAO {

    private final UserDAO userDAO;    // Dependency for fetching User objects
    private final ProjectDAO projectDAO; // Dependency for fetching Project objects

    // DateTimeFormatter for converting LocalDateTime to and from String for SQLite TEXT storage
    private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ISO_LOCAL_DATE_TIME;

    /**
     * Constructs a TaskDAO with UserDAO and ProjectDAO dependencies.
     *
     * @param userDAO The Data Access Object for User entities.
     * @param projectDAO The Data Access Object for Project entities.
     */
    public TaskDAO(UserDAO userDAO, ProjectDAO projectDAO) {
        this.userDAO = userDAO;
        this.projectDAO = projectDAO;
    }

    /**
     * Inserts a new task into the database.
     * The task's ID will be auto-generated by the database and set back into the Task object.
     *
     * @param task The Task object to be saved.
     * @return The Task object with its database-generated ID, or null if the insertion failed.
     */
    public Task createTask(Task task) {
        String sql = "INSERT INTO Tasks(title, description, due_date, priority, status, assigned_to_user_id, project_id, visibility, creator_id) VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?)";
        try (Connection conn = DatabaseManager.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {

            pstmt.setString(1, task.getTitle());
            pstmt.setString(2, task.getDescription());
            pstmt.setString(3, task.getDueDate() != null ? task.getDueDate().format(FORMATTER) : null); // Convert LocalDateTime to String
            pstmt.setString(4, task.getPriority().name()); // Store enum name as String
            pstmt.setString(5, task.getStatus().name());   // Store enum name as String

            if (task.getAssignedTo() != null) {
                pstmt.setInt(6, task.getAssignedTo().getId());
            } else {
                pstmt.setNull(6, java.sql.Types.INTEGER);
            }

            if (task.getProject() != null) {
                pstmt.setInt(7, task.getProject().getId());
            } else {
                pstmt.setNull(7, java.sql.Types.INTEGER);
            }
            pstmt.setString(8, task.getVisibility().name()); // Store Visibility enum name as String
            pstmt.setInt(9, task.getCreator().getId()); // Store Creator ID

            int affectedRows = pstmt.executeUpdate();

            if (affectedRows > 0) {
                try (ResultSet generatedKeys = pstmt.getGeneratedKeys()) {
                    if (generatedKeys.next()) {
                        task.setId(generatedKeys.getInt(1)); // Set the generated ID back to the task object
                        System.out.println("Task created successfully with ID: " + task.getId());
                        return task;
                    }
                }
            }
        } catch (SQLException e) {
            System.err.println("Error creating task: " + e.getMessage());
            // Log the exception for debugging
        }
        return null;
    }

    /**
     * Retrieves a task from the database by its ID.
     *
     * @param id The ID of the task to retrieve.
     * @return An Optional containing the Task object if found, or an empty Optional if not found.
     */
    public Optional<Task> getTaskById(int id) {
        String sql = "SELECT id, title, description, due_date, priority, status, assigned_to_user_id, project_id, visibility, creator_id FROM Tasks WHERE id = ?";
        try (Connection conn = DatabaseManager.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setInt(1, id);
            try (ResultSet rs = pstmt.executeQuery()) {
                if (rs.next()) {
                    return Optional.of(extractTaskFromResultSet(rs));
                }
            }
        } catch (SQLException e) {
            System.err.println("Error retrieving task by ID: " + e.getMessage());
        }
        return Optional.empty();
    }

    /**
     * Retrieves all tasks from the database.
     *
     * @return A list of all Task objects found in the database.
     */
    public List<Task> getAllTasks() {
        List<Task> tasks = new ArrayList<>();
        String sql = "SELECT id, title, description, due_date, priority, status, assigned_to_user_id, project_id, visibility, creator_id FROM Tasks";
        try (Connection conn = DatabaseManager.getConnection();
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {

            while (rs.next()) {
                tasks.add(extractTaskFromResultSet(rs));
            }
        } catch (SQLException e) {
            System.err.println("Error retrieving all tasks: " + e.getMessage());
        }
        return tasks;
    }

    /**
     * Retrieves tasks assigned to a specific user.
     *
     * @param userId The ID of the user.
     * @return A list of Task objects assigned to the given user.
     */
    public List<Task> getTasksByAssignedUserId(int userId) {
        List<Task> tasks = new ArrayList<>();
        String sql = "SELECT id, title, description, due_date, priority, status, assigned_to_user_id, project_id, visibility, creator_id FROM Tasks WHERE assigned_to_user_id = ?";
        try (Connection conn = DatabaseManager.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setInt(1, userId);
            try (ResultSet rs = pstmt.executeQuery()) {
                while (rs.next()) {
                    tasks.add(extractTaskFromResultSet(rs));
                }
            }
        } catch (SQLException e) {
            System.err.println("Error retrieving tasks by assigned user ID: " + e.getMessage());
        }
        return tasks;
    }

    /**
     * Retrieves tasks belonging to a specific project.
     *
     * @param projectId The ID of the project.
     * @return A list of Task objects belonging to the given project.
     */
    public List<Task> getTasksByProjectId(int projectId) {
        List<Task> tasks = new ArrayList<>();
        String sql = "SELECT id, title, description, due_date, priority, status, assigned_to_user_id, project_id, visibility, creator_id FROM Tasks WHERE project_id = ?";
        try (Connection conn = DatabaseManager.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setInt(1, projectId);
            try (ResultSet rs = pstmt.executeQuery()) {
                while (rs.next()) {
                    tasks.add(extractTaskFromResultSet(rs));
                }
            }
        } catch (SQLException e) {
            System.err.println("Error retrieving tasks by project ID: " + e.getMessage());
        }
        return tasks;
    }

    /**
     * Updates an existing task's information in the database.
     * The task's ID must be set for the update to occur.
     *
     * @param task The Task object containing the updated information.
     * @return true if the task was updated successfully, false otherwise.
     */
    public boolean updateTask(Task task) {
        String sql = "UPDATE Tasks SET title = ?, description = ?, due_date = ?, priority = ?, status = ?, assigned_to_user_id = ?, project_id = ?, visibility = ?, creator_id = ? WHERE id = ?";
        try (Connection conn = DatabaseManager.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setString(1, task.getTitle());
            pstmt.setString(2, task.getDescription());
            pstmt.setString(3, task.getDueDate() != null ? task.getDueDate().format(FORMATTER) : null);
            pstmt.setString(4, task.getPriority().name());
            pstmt.setString(5, task.getStatus().name());

            if (task.getAssignedTo() != null) {
                pstmt.setInt(6, task.getAssignedTo().getId());
            } else {
                pstmt.setNull(6, java.sql.Types.INTEGER);
            }

            if (task.getProject() != null) {
                pstmt.setInt(7, task.getProject().getId());
            } else {
                pstmt.setNull(7, java.sql.Types.INTEGER);
            }
            pstmt.setString(8, task.getVisibility().name()); // Update Visibility enum name as String
            pstmt.setInt(9, task.getCreator().getId()); // Update Creator ID
            pstmt.setInt(10, task.getId());

            int affectedRows = pstmt.executeUpdate();
            return affectedRows > 0;
        } catch (SQLException e) {
            System.err.println("Error updating task: " + e.getMessage());
        }
        return false;
    }

    /**
     * Deletes a task from the database by its ID.
     *
     * @param id The ID of the task to delete.
     * @return true if the task was deleted successfully, false otherwise.
     */
    public boolean deleteTask(int id) {
        String sql = "DELETE FROM Tasks WHERE id = ?";
        try (Connection conn = DatabaseManager.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setInt(1, id);

            int affectedRows = pstmt.executeUpdate();
            return affectedRows > 0;
        } catch (SQLException e) {
            System.err.println("Error deleting task: " + e.getMessage());
        }
        return false;
    }

    /**
     * Helper method to extract a Task object from a ResultSet.
     * This centralizes the logic for mapping database rows to Task objects.
     *
     * @param rs The ResultSet containing the task data.
     * @return A Task object populated with data from the ResultSet.
     * @throws SQLException If a database access error occurs or this method is called on a closed result set.
     */
    private Task extractTaskFromResultSet(ResultSet rs) throws SQLException {
        int taskId = rs.getInt("id");
        String title = rs.getString("title");
        String description = rs.getString("description");
        String dueDateStr = rs.getString("due_date");
        LocalDateTime dueDate = (dueDateStr != null) ? LocalDateTime.parse(dueDateStr, FORMATTER) : null;

        Priority priority = Priority.valueOf(rs.getString("priority"));
        Status status = Status.valueOf(rs.getString("status"));

        int assignedToUserId = rs.getInt("assigned_to_user_id");
        User assignedTo = null;
        if (!rs.wasNull()) {
            assignedTo = userDAO.getUserById(assignedToUserId).orElse(null);
        }

        int projectId = rs.getInt("project_id");
        Project project = null;
        if (!rs.wasNull()) {
            project = projectDAO.getProjectById(projectId).orElse(null);
        }

        Visibility visibility = Visibility.valueOf(rs.getString("visibility")); // Extract Visibility

        int creatorId = rs.getInt("creator_id"); // Extract Creator ID
        User creator = userDAO.getUserById(creatorId)
                .orElseThrow(() -> new SQLException("Associated User (creator) not found for task ID: " + taskId));


        return new Task(taskId, title, description, dueDate, priority, status, assignedTo, project, visibility, creator);
    }
}
